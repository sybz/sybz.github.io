<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[如何在iOS App的图标上显示版本信息]]></title>
      <url>%2F2017%2F02%2F21%2F%E5%A6%82%E4%BD%95%E5%9C%A8iOS-App%E7%9A%84%E5%9B%BE%E6%A0%87%E4%B8%8A%E6%98%BE%E7%A4%BA%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF%2F</url>
      <content type="text"><![CDATA[作用在iOS App的图标上显示版本信息，帮助测试人员在测试多版本的时候直接从桌面icon上看到当前的版本，无需再到App内或者TestFlight中去看测试机使用的哪个版本。可以极大的提升效率，不仅限于版本信息，同时还可以显示git分支，commit id等。对于开发者来说，理解这一过程可以加深对Xcode编译过程的理解，同时也可以学到一些shell脚本的知识。 来源最早想到方法的人应该是国外的一个大神，文章链接在这Overlaying application version on top of your icon这篇blog的最后有个demo，它的功能非常强大，只要你的电脑装好工具可以直接应用在几乎任何iOS项目中。Demo下载地址本文是自己对这篇blog的理解和分析 效果 实现对照效果图我们来大致猜测一下这个的实现流程。首先是怎样取到你想要展示的信息(例如Vesion，bulid版本),再就是是如何把文字写到图片上，然后把带有信息的图片与app Icon进行合成。最后在Xcode编译过程中实现图片替换（这里的实现方式是，在将上述过程写成一个shell脚本，在Xcode的Build Phases选项中加入这一脚本）： 1. 使用PlistBuddy工具，获取version,build信息.plist文件是Mac种非常普遍的一种文件格式，类似xml，通过键值对的方式来进行一些配置。而PlistBuddy则是Mac自带的专门解析plist的小工具，由于PlistBuddy并不在Mac默认的Path里，所以我们得通过绝对路径来引用这个工具,在终端（Terminal）输入以下命令可查看帮助 1➜ ✗ /usr/libexec/PlistBuddy --help 提取App的Info.plist中的Version信息可以使用以下命令 1➜ ✗ /usr/libexec/PlistBuddy -c "Print CFBundleShortVersionString" Info.plist路径 提取App的Info.plist中的build信息可以使用以下命令 1➜ ✗ /usr/libexec/PlistBuddy -c "Print CFBundleVersion" Info.plist路径 2. git命令获取分支信息和commit id获取分支 1git rev-parse --abbrev-ref HEAD 获取commit id 1git rev-parse --short HEAD 3.使用ImageMagick将版本信息填充到图标上这里实际上需要安装2个工具：ImageMagick和ghostscript。最好是先安装ghostscript，因为ImageMagick要用到它，有点类似CocoaPods的依赖关系（s.dependency)，但是这里不会自动安装，需要我们手动操作，使用Homebrew运行以下两个命令： 12➜ ✗ brew install ghostscript ➜ ✗ brew install imagemagick 安装好后，通过ImageMagicK的convert功能把文字写到图片上,示例：在Icon-76.png上，创建一个背景色为蓝色，透明度为80%的颜色’#0098’，这种颜色表示法有点像我们平常见到的rgba色值，不过rgb取值不再是0~255，而是0~9，我们可以根据需要设置不同的背景色。接着指定大小，长为76，高为30的矩形。然后用白色字体把“NextStep”居中写到矩形中。这里字体颜色也可以用前面那种颜色表示，例如想让字体为红色可以将‘white’替换成’#9008’。 123convert -background '#0098' -fill white -gravity center -size 76x30 \ caption:"NextStep" ./Icon-76.png \+swap -gravity south -composite ./convert.png 动图中可以看到文字的背景由蓝色变成了红色 4.实现替换icon的功能上面只是将用到的工具列出来，但离实现我们的需求还有很大的距离，真正有趣的东西是源码中的iconVersioning.sh文件，我把它粘贴在文章末尾。他的工作就是把上面的各种命令进行组合，虽然里面的内容很多，但是如果分成模块来解读将很容易理解，我把它分成4个模块，如下： A，1~56行：读取版本，git信息，第56行，最终读取的信息会保存在caption中，第19~29行作用是提示怎样安装必须的工具。 B，58行：函数abspath（这个实在太长了，所以下面贴的源文件删了函数体），作用是显示一个文件的绝对路径。仅仅是显示，对脚本功能其实没有影响，可以通过注释该方法的调用（第66，67行）进行验证，注释这两行后不影响脚本执行。 C，60~140行：函数processIcon，他的功能是创建带有额外信息的图片，不是在原图上直接加，而是有几个过程：复制（第95行），文件重命名（第115，119行），添加版本信息（第147行）。因为Xcode编译过后的图片实际是被压缩了，使用此命令xcrun -sdk iphoneos pngcrush -revert-iphone-optimizations -q会将图片转成普通的格式。 D，142~161行：找到所有需要替换的图片，循环调用函数processIcon。这里才是真正的入口。前面只是在定义变量和函数，真正的调用发生在这里。 他做的的事情就是读取一个info.plist文件，文件的路径是这${CONFIGURATION_BUILD_DIR}/${INFOPLIST_PATH}实际位置如下图： 显示包内容，就可以看到info.plist文件 info.plist的具体内容如下 现在再看第142，147行就可以轻松理解了，读取路径是${CONFIGURATION_BUILD_DIR}/${INFOPLIST_PATH}的文件，找到CFBundleIcons~ipad:CFBundlePrimaryIcon:CFBundleIconFiles这个key对应的数据，是一个保存图片名称的数组。把图片名当成参数传入函数processIcon，实现icon的更换。CONFIGURATION_BUILD_DIR代表环境变量，可以到Apple的开发者网站上查到所有这种类型变量的含义。 5.在Xcode编译的过程中运行脚本，查看编译logXcode的Build Phases选项中新增Run Script，添加上述.sh文件到选项中。查看脚本的log信息可以在Xcode进行查看。实际就是脚本中的echo命令输出的内容 总结这里面其实涉及了非常多的shell脚本方面的知识，里面的命令行程序一共十多种，想要真正弄懂全部过程要对这些命令有一定程度的了解。例如“which”判断某个命令是否存在（第4行），“mv”重命名或者移动文件（第115行），“basename”命令用于去掉文件名的目录和后缀（第89行）。如果遇到不懂的命令有一个“man”命令可以辅助我们理解，例如在终端中输入“man basename”可以看到命令行的使用文档，另外是shell编程内的流程控制语法if-then-fi，用反引号``表示执行命令等等，当我们遇到问题时需要借助各种工具去解决问题，当别人已经有了解决方法时，我们也应该中学习经验，了解用到的工具，亲手去调试，而不只是看看，最好自己再写一遍。如果你把源代码的中的.sh文件删了，自己从头开始创建的话，必须使用到一个特殊的命令，有兴趣的可以去研究下！ 我自己写了一个demo修改了一下脚本中读取plist的方法，原始代码应用到纯iPhone的APP会有问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#!/bin/shexport PATH=/opt/local/bin/:/opt/local/sbin:$PATH:/usr/local/bin:convertPath=`which convert`gsPath=`which gs`if [[ ! -f $&#123;convertPath&#125; || -z $&#123;convertPath&#125; ]]; then convertValidation=true;else convertValidation=false;fiif [[ ! -f $&#123;gsPath&#125; || -z $&#123;gsPath&#125; ]]; then gsValidation=true;else gsValidation=false;fiif [[ "$convertValidation" = true || "$gsValidation" = true ]]; then echo "WARNING: Skipping Icon versioning, you need to install ImageMagick and ghostscript (fonts) first, you can use brew to simplify process:" if [[ "$convertValidation" = true ]]; then echo "brew install imagemagick" fi if [[ "$gsValidation" = true ]]; then echo "brew install ghostscript" fiexit 0;fiversion=`/usr/libexec/PlistBuddy -c "Print CFBundleShortVersionString" "$&#123;CONFIGURATION_BUILD_DIR&#125;/$&#123;INFOPLIST_PATH&#125;"`build_num=`/usr/libexec/PlistBuddy -c "Print CFBundleVersion" "$&#123;CONFIGURATION_BUILD_DIR&#125;/$&#123;INFOPLIST_PATH&#125;"`# Check if we are under a Git or Hg repoif [ -d .git ] || git rev-parse --git-dir &gt; /dev/null 2&gt;&amp;1; then commit=`git rev-parse --short HEAD` branch=`git rev-parse --abbrev-ref HEAD`else commit=`hg identify -i` branch=`hg identify -b`fi;#SRCROOT=..#CONFIGURATION_BUILD_DIR=.#UNLOCALIZED_RESOURCES_FOLDER_PATH=.#commit="3783bab"#branch="master"#version="3.4"#build_num="9999"shopt -s extglobbuild_num="$&#123;build_num##*( )&#125;"shopt -u extglobcaption="$&#123;version&#125; ($build_num)\n$&#123;branch&#125;\n$&#123;commit&#125;"echo $captionfunction abspath() &#123; &#125;function processIcon() &#123; base_file=$1 cd "$&#123;CONFIGURATION_BUILD_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;" base_path=`find . -name $&#123;base_file&#125;` real_path=$( abspath "$&#123;base_path&#125;" ) echo "base path $&#123;real_path&#125;" if [[ ! -f $&#123;base_path&#125; || -z $&#123;base_path&#125; ]]; then return; fi # TODO: if they are the same we need to fix it by introducing temp target_file=`basename $base_path` target_path="$&#123;CONFIGURATION_BUILD_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;/$&#123;target_file&#125;" base_tmp_normalizedFileName="$&#123;base_file%.*&#125;-normalized.$&#123;base_file##*.&#125;" base_tmp_path=`dirname $base_path` base_tmp_normalizedFilePath="$&#123;base_tmp_path&#125;/$&#123;base_tmp_normalizedFileName&#125;" stored_original_file="$&#123;base_tmp_normalizedFilePath&#125;-tmp" if [[ -f $&#123;stored_original_file&#125; ]]; then echo "found previous file at path $&#123;stored_original_file&#125;, using it as base" mv "$&#123;stored_original_file&#125;" "$&#123;base_path&#125;" fi if [ $CONFIGURATION = "Release" ]; then cp "$&#123;base_path&#125;" "$target_path" return 0; fi echo "Reverting optimized PNG to normal" # Normalize echo "xcrun -sdk iphoneos pngcrush -revert-iphone-optimizations -q $&#123;base_path&#125; $&#123;base_tmp_normalizedFilePath&#125;" xcrun -sdk iphoneos pngcrush -revert-iphone-optimizations -q "$&#123;base_path&#125;" "$&#123;base_tmp_normalizedFilePath&#125;" # move original pngcrush png to tmp file echo "moving pngcrushed png file at $&#123;base_path&#125; to $&#123;stored_original_file&#125;" #rm "$base_path" mv "$base_path" "$&#123;stored_original_file&#125;" # Rename normalized png's filename to original one echo "Moving normalized png file to original one $&#123;base_tmp_normalizedFilePath&#125; to $&#123;base_path&#125;" mv "$&#123;base_tmp_normalizedFilePath&#125;" "$&#123;base_path&#125;" width=`identify -format %w $&#123;base_path&#125;` height=`identify -format %h $&#123;base_path&#125;` band_height=$((($height * 47) / 100)) band_position=$(($height - $band_height)) text_position=$(($band_position - 3)) point_size=$(((13 * $width) / 100)) echo "Image dimensions ($width x $height) - band height $band_height @ $band_position - point size $point_size" # # blur band and text # convert $&#123;base_path&#125; -blur 10x8 /tmp/blurred.png convert /tmp/blurred.png -gamma 0 -fill white -draw "rectangle 0,$band_position,$width,$height" /tmp/mask.png convert -size $&#123;width&#125;x$&#123;band_height&#125; xc:none -fill 'rgba(0,0,0,0.2)' -draw "rectangle 0,0,$width,$band_height" /tmp/labels-base.png convert -background none -size $&#123;width&#125;x$&#123;band_height&#125; -pointsize $point_size -fill white -gravity center -gravity South caption:"$caption" /tmp/labels.png convert $&#123;base_path&#125; /tmp/blurred.png /tmp/mask.png -composite /tmp/temp.png rm /tmp/blurred.png rm /tmp/mask.png # # compose final image # filename=New$&#123;base_file&#125; convert /tmp/temp.png /tmp/labels-base.png -geometry +0+$band_position -composite /tmp/labels.png -geometry +0+$text_position -geometry +$&#123;w&#125;-$&#123;h&#125; -composite "$&#123;target_path&#125;" # clean up rm /tmp/temp.png rm /tmp/labels-base.png rm /tmp/labels.png echo "Overlayed $&#123;target_path&#125;"&#125;icon_count=`/usr/libexec/PlistBuddy -c "Print CFBundleIcons~ipad:CFBundlePrimaryIcon:CFBundleIconFiles" "$&#123;CONFIGURATION_BUILD_DIR&#125;/$&#123;INFOPLIST_PATH&#125;" | wc -l`last_icon_index=$(($&#123;icon_count&#125; - 2))i=0while [ $i -lt $last_icon_index ]; do icon=`/usr/libexec/PlistBuddy -c "Print CFBundleIcons~ipad:CFBundlePrimaryIcon:CFBundleIconFiles:$i" "$&#123;CONFIGURATION_BUILD_DIR&#125;/$&#123;INFOPLIST_PATH&#125;"` if [[ $icon == *.png ]] || [[ $icon == *.PNG ]] then processIcon $icon else processIcon "$&#123;icon&#125;.png" processIcon "$&#123;icon&#125;@2x.png" processIcon "$&#123;icon&#125;@3x.png" processIcon "$&#123;icon&#125;~ipad.png" processIcon "$&#123;icon&#125;@2x~ipad.png" fi let i=i+1done# Workaround to fix issue#16 to use wildcard * to actually find the file# Only 72x72 and 76x76 that we need for ipad app icons#processIcon "AppIcon72x72~ipad*"#processIcon "AppIcon72x72@2x~ipad*"#processIcon "AppIcon76x76~ipad*"#processIcon "AppIcon76x76@2x~ipad*"]]></content>
    </entry>

    
  
  
</search>
