{"meta":{"title":"三月不知","subtitle":"我们都是星尘！","description":null,"author":"wang xin","url":"http://www.sybzrw.com"},"pages":[{"title":"","date":"2016-09-25T16:02:04.000Z","updated":"2016-01-23T09:40:55.000Z","comments":true,"path":"404.html","permalink":"http://www.sybzrw.com/404.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null},{"title":"categories","date":"2016-01-22T05:05:09.000Z","updated":"2016-05-07T02:03:50.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.sybzrw.com/categories/index.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null},{"title":"tags","date":"2016-01-22T02:31:37.000Z","updated":"2017-02-23T17:46:32.000Z","comments":false,"path":"tags/index.html","permalink":"http://www.sybzrw.com/tags/index.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null}],"posts":[{"title":"如何在iOS App的图标上显示版本信息","slug":"如何在iOS-App的图标上显示版本信息","date":"2017-02-21T13:13:32.000Z","updated":"2017-02-23T17:40:10.000Z","comments":true,"path":"2017/02/21/如何在iOS-App的图标上显示版本信息/","link":"","permalink":"http://www.sybzrw.com/2017/02/21/如何在iOS-App的图标上显示版本信息/","excerpt":"","keywords":null,"text":"作用在iOS App的图标上显示版本信息，测试人员在测试多版本的时候，可以直接从桌面icon上看到当前测试的版本，无需再到App内或者TestFlight中去看测试机使用的哪个版本，可以极大的提升效率。不仅限于版本信息，同时还可以显示git分支，commit id等。对于开发者来说，理解这一过程可以加深对Xcode编译过程的理解，同时也可以学到一些shell的知识。 来源最早想到方法的人应该是国外的一个大神，文章链接在这Overlaying application version on top of your icon同时作者给出了Demo下载地址本文大部分是参照这篇bolg来写的，加上一些自己的理解以及对源代码中脚本的分析 效果 实现对一个没有接触过这方面技术的人来说，对照效果图我们来大致猜测一下这个的实现流程。首先是怎样取到你想要展示的信息(例如Vesion，bulid版本),然后就是是如何把文字写到图片上，最后是把带有信息的图片与app Icon进行合成。这几个过程缺一不可，以下内容将对这些技术进行讲解。 1. 使用PlistBuddy工具，获取version,build信息.plist文件是Mac种非常普遍的一种文件格式，类似xml，通过键值对的方式来进行一些配置。而PlistBuddy则是Mac自带的专门解析plist的小工具，由于PlistBuddy并不在Mac默认的Path里，所以我们得通过绝对路径来引用这个工具,在终端（Terminal）输入以下命令可查看帮助 1➜ ✗ /usr/libexec/PlistBuddy --help 提取App的Info.plist中的Version信息可以使用以下命令 1➜ ✗ /usr/libexec/PlistBuddy -c \"Print CFBundleShortVersionString\" Info.plist路径 提取App的Info.plist中的build信息可以使用以下命令 1➜ ✗ /usr/libexec/PlistBuddy -c \"Print CFBundleVersion\" Info.plist路径 2. git命令获取分支信息和commit id获取分支 1git rev-parse --abbrev-ref HEAD 获取commit id 1git rev-parse --short HEAD 3.使用ImageMagick将版本信息填充到图标上这里实际上需要安装2个工具：ImageMagick和ghostscript。最好是先安装ghostscript，因为ImageMagick要用到它，有点类似CocoaPods的依赖关系（s.dependency)，但是这里不会自动安装，需要我们手动操作，使用Homebrew运行以下两个命令： 12➜ ✗ brew install ghostscript ➜ ✗ brew install imagemagick 安装好后，通过ImageMagicK的convert功能把文字写到图片上,示例：在Icon-76.png上，创建一个背景色为蓝色，透明度为80%的颜色’#0098’，这种颜色表示法有点像我们平常见到的rgba色值，不过rgb取值不再是0~255，而是0~9，我们可以根据喜好设置不同的背景色。接着指定大小，长为76，高为30的矩形。然后用白色字体把“NextStep”居中写到矩形中。这里字体颜色也可以用前面那种颜色表示，例如想让字体为红色可以将‘white’替换成’#9008’。 123convert -background '#0098' -fill white -gravity center -size 76x30 \\ caption:\"NextStep\" ./Icon-76.png \\+swap -gravity south -composite ./convert.png 最终可以达到的效果： 如何整合进Xcode，实现编译的时候动态修改icon123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#!/bin/shexport PATH=/opt/local/bin/:/opt/local/sbin:$PATH:/usr/local/bin:convertPath=`which convert`gsPath=`which gs`if [[ ! -f $&#123;convertPath&#125; || -z $&#123;convertPath&#125; ]]; then convertValidation=true;else convertValidation=false;fiif [[ ! -f $&#123;gsPath&#125; || -z $&#123;gsPath&#125; ]]; then gsValidation=true;else gsValidation=false;fiif [[ \"$convertValidation\" = true || \"$gsValidation\" = true ]]; then echo \"WARNING: Skipping Icon versioning, you need to install ImageMagick and ghostscript (fonts) first, you can use brew to simplify process:\" if [[ \"$convertValidation\" = true ]]; then echo \"brew install imagemagick\" fi if [[ \"$gsValidation\" = true ]]; then echo \"brew install ghostscript\" fiexit 0;fiversion=`/usr/libexec/PlistBuddy -c \"Print CFBundleShortVersionString\" \"$&#123;CONFIGURATION_BUILD_DIR&#125;/$&#123;INFOPLIST_PATH&#125;\"`build_num=`/usr/libexec/PlistBuddy -c \"Print CFBundleVersion\" \"$&#123;CONFIGURATION_BUILD_DIR&#125;/$&#123;INFOPLIST_PATH&#125;\"`# Check if we are under a Git or Hg repoif [ -d .git ] || git rev-parse --git-dir &gt; /dev/null 2&gt;&amp;1; then commit=`git rev-parse --short HEAD` branch=`git rev-parse --abbrev-ref HEAD`else commit=`hg identify -i` branch=`hg identify -b`fi;#SRCROOT=..#CONFIGURATION_BUILD_DIR=.#UNLOCALIZED_RESOURCES_FOLDER_PATH=.#commit=\"3783bab\"#branch=\"master\"#version=\"3.4\"#build_num=\"9999\"shopt -s extglobbuild_num=\"$&#123;build_num##*( )&#125;\"shopt -u extglobcaption=\"$&#123;version&#125; ($build_num)\\n$&#123;branch&#125;\\n$&#123;commit&#125;\"echo $captionfunction abspath() &#123; &#125;function processIcon() &#123; base_file=$1 cd \"$&#123;CONFIGURATION_BUILD_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;\" base_path=`find . -name $&#123;base_file&#125;` echo \"------base path $&#123;base_path&#125;\" real_path=$( abspath \"$&#123;base_path&#125;\" ) echo \"base path $&#123;real_path&#125;\" if [[ ! -f $&#123;base_path&#125; || -z $&#123;base_path&#125; ]]; then return; fi # TODO: if they are the same we need to fix it by introducing temp target_file=`basename $base_path` target_path=\"$&#123;CONFIGURATION_BUILD_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;/$&#123;target_file&#125;\" base_tmp_normalizedFileName=\"$&#123;base_file%.*&#125;-normalized.$&#123;base_file##*.&#125;\" base_tmp_path=`dirname $base_path` base_tmp_normalizedFilePath=\"$&#123;base_tmp_path&#125;/$&#123;base_tmp_normalizedFileName&#125;\" stored_original_file=\"$&#123;base_tmp_normalizedFilePath&#125;-tmp\" if [[ -f $&#123;stored_original_file&#125; ]]; then echo \"found previous file at path $&#123;stored_original_file&#125;, using it as base\" mv \"$&#123;stored_original_file&#125;\" \"$&#123;base_path&#125;\" fi if [ $CONFIGURATION = \"Release\" ]; then cp \"$&#123;base_path&#125;\" \"$target_path\" return 0; fi echo \"Reverting optimized PNG to normal\" # Normalize echo \"xcrun -sdk iphoneos pngcrush -revert-iphone-optimizations -q $&#123;base_path&#125; $&#123;base_tmp_normalizedFilePath&#125;\" xcrun -sdk iphoneos pngcrush -revert-iphone-optimizations -q \"$&#123;base_path&#125;\" \"$&#123;base_tmp_normalizedFilePath&#125;\" # move original pngcrush png to tmp file echo \"moving pngcrushed png file at $&#123;base_path&#125; to $&#123;stored_original_file&#125;\" #rm \"$base_path\" mv \"$base_path\" \"$&#123;stored_original_file&#125;\" # Rename normalized png's filename to original one echo \"Moving normalized png file to original one $&#123;base_tmp_normalizedFilePath&#125; to $&#123;base_path&#125;\" mv \"$&#123;base_tmp_normalizedFilePath&#125;\" \"$&#123;base_path&#125;\" width=`identify -format %w $&#123;base_path&#125;` height=`identify -format %h $&#123;base_path&#125;` band_height=$((($height * 47) / 100)) band_position=$(($height - $band_height)) text_position=$(($band_position - 3)) point_size=$(((13 * $width) / 100)) echo \"Image dimensions ($width x $height) - band height $band_height @ $band_position - point size $point_size\" # # blur band and text # convert $&#123;base_path&#125; -blur 10x8 /tmp/blurred.png convert /tmp/blurred.png -gamma 0 -fill white -draw \"rectangle 0,$band_position,$width,$height\" /tmp/mask.png convert -size $&#123;width&#125;x$&#123;band_height&#125; xc:none -fill 'rgba(0,0,0,0.2)' -draw \"rectangle 0,0,$width,$band_height\" /tmp/labels-base.png convert -background none -size $&#123;width&#125;x$&#123;band_height&#125; -pointsize $point_size -fill white -gravity center -gravity South caption:\"$caption\" /tmp/labels.png convert $&#123;base_path&#125; /tmp/blurred.png /tmp/mask.png -composite /tmp/temp.png rm /tmp/blurred.png rm /tmp/mask.png # # compose final image # filename=New$&#123;base_file&#125; convert /tmp/temp.png /tmp/labels-base.png -geometry +0+$band_position -composite /tmp/labels.png -geometry +0+$text_position -geometry +$&#123;w&#125;-$&#123;h&#125; -composite \"$&#123;target_path&#125;\" # clean up rm /tmp/temp.png rm /tmp/labels-base.png rm /tmp/labels.png echo \"Overlayed $&#123;target_path&#125;\"&#125;icon_count=`/usr/libexec/PlistBuddy -c \"Print CFBundleIcons~ipad:CFBundlePrimaryIcon:CFBundleIconFiles\" \"$&#123;CONFIGURATION_BUILD_DIR&#125;/$&#123;INFOPLIST_PATH&#125;\" | wc -l`last_icon_index=$(($&#123;icon_count&#125; - 2))i=0while [ $i -lt $last_icon_index ]; do icon=`/usr/libexec/PlistBuddy -c \"Print CFBundleIcons~ipad:CFBundlePrimaryIcon:CFBundleIconFiles:$i\" \"$&#123;CONFIGURATION_BUILD_DIR&#125;/$&#123;INFOPLIST_PATH&#125;\"` echo $icon echo \"wangxin\" if [[ $icon == *.png ]] || [[ $icon == *.PNG ]] then processIcon $icon else processIcon \"$&#123;icon&#125;.png\" processIcon \"$&#123;icon&#125;@2x.png\" processIcon \"$&#123;icon&#125;@3x.png\" processIcon \"$&#123;icon&#125;~ipad.png\" processIcon \"$&#123;icon&#125;@2x~ipad.png\" fi let i=i+1done# Workaround to fix issue#16 to use wildcard * to actually find the file# Only 72x72 and 76x76 that we need for ipad app icons#processIcon \"AppIcon72x72~ipad*\"#processIcon \"AppIcon72x72@2x~ipad*\"#processIcon \"AppIcon76x76~ipad*\"#processIcon \"AppIcon76x76@2x~ipad*\"","raw":null,"content":null,"categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.sybzrw.com/tags/iOS/"}]}]}